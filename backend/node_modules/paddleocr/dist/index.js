(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.paddleocr = {}));
})(this, (function (exports) { 'use strict';

    class Image {
        width;
        height;
        data;
        depth;
        channels;
        constructor(width, height, channels, data) {
            this.width = width;
            this.height = height;
            this.channels = channels;
            this.depth = 8;
            if (data) {
                this.data = data;
            }
            else {
                const length = width * height * 4;
                this.data = new Uint8Array(length);
            }
        }
        crop(options) {
            const { x, y, width, height } = options;
            if (x < 0 || y < 0 || x + width > this.width || y + height > this.height) {
                throw new Error("Crop area is out of bounds");
            }
            const croppedData = new Uint8Array(width * height * this.channels);
            for (let j = 0; j < height; j++) {
                for (let i = 0; i < width; i++) {
                    const srcIndex = ((y + j) * this.width + (x + i)) * this.channels;
                    const dstIndex = (j * width + i) * this.channels;
                    croppedData.set(this.data.subarray(srcIndex, srcIndex + this.channels), dstIndex);
                }
            }
            return new Image(width, height, this.channels, croppedData);
        }
        resize(options) {
            let { width, height } = options;
            if (!width && !height) {
                throw new Error("At least one of width or height must be specified");
            }
            if (!width)
                width = Math.round(this.width * (height / this.height));
            if (!height)
                height = Math.round(this.height * (width / this.width));
            const srcW = this.width;
            const srcH = this.height;
            const dstW = width;
            const dstH = height;
            const channels = this.channels;
            const srcData = this.data;
            function triangle_kernel(x) {
                x = Math.abs(x);
                return x < 1 ? 1 - x : 0;
            }
            function clamp(v, min, max) {
                return Math.max(min, Math.min(max, v));
            }
            const tmpData = new Float32Array(srcW * dstH * channels);
            const ratioY = srcH / dstH;
            const sratioY = ratioY < 1 ? 1 : ratioY;
            const supportY = 1.0 * sratioY;
            for (let outy = 0; outy < dstH; outy++) {
                const inputy = (outy + 0.5) * ratioY - 0.5;
                const left = Math.max(0, Math.floor(inputy - supportY));
                const right = Math.min(srcH, Math.ceil(inputy + supportY));
                const ws = [];
                let sum = 0;
                for (let i = left; i < right; i++) {
                    const w = triangle_kernel((i - inputy) / sratioY);
                    ws.push(w);
                    sum += w;
                }
                for (let i = 0; i < ws.length; i++)
                    ws[i] /= sum;
                for (let x = 0; x < srcW; x++) {
                    for (let c = 0; c < channels; c++) {
                        let t = 0;
                        for (let i = 0; i < ws.length; i++) {
                            const srcIdx = ((left + i) * srcW + x) * channels + c;
                            t += srcData[srcIdx] * ws[i];
                        }
                        tmpData[(outy * srcW + x) * channels + c] = t;
                    }
                }
            }
            const dstData = new Uint8Array(dstW * dstH * channels);
            const ratioX = srcW / dstW;
            const sratioX = ratioX < 1 ? 1 : ratioX;
            const supportX = 1.0 * sratioX;
            for (let outx = 0; outx < dstW; outx++) {
                const inputx = (outx + 0.5) * ratioX - 0.5;
                const left = Math.max(0, Math.floor(inputx - supportX));
                const right = Math.min(srcW, Math.ceil(inputx + supportX));
                const ws = [];
                let sum = 0;
                for (let i = left; i < right; i++) {
                    const w = triangle_kernel((i - inputx) / sratioX);
                    ws.push(w);
                    sum += w;
                }
                for (let i = 0; i < ws.length; i++)
                    ws[i] /= sum;
                for (let y = 0; y < dstH; y++) {
                    for (let c = 0; c < channels; c++) {
                        let t = 0;
                        for (let i = 0; i < ws.length; i++) {
                            const srcIdx = (y * srcW + (left + i)) * channels + c;
                            t += tmpData[srcIdx] * ws[i];
                        }
                        dstData[(y * dstW + outx) * channels + c] = Math.round(clamp(t, 0, 255));
                    }
                }
            }
            return new Image(dstW, dstH, channels, dstData);
        }
        padding(options) {
            let { padding, vertical, horizontal, top, bottom, left, right, color } = options;
            if (typeof padding === "number") {
                top = bottom = left = right = padding;
            }
            else {
                if (typeof vertical === "number") {
                    top = bottom = vertical;
                }
                if (typeof horizontal === "number") {
                    left = right = horizontal;
                }
            }
            top = top ?? 0;
            bottom = bottom ?? 0;
            left = left ?? 0;
            right = right ?? 0;
            color = color ?? [0, 0, 0, 0];
            const newW = this.width + left + right;
            const newH = this.height + top + bottom;
            const newData = new Uint8Array(newW * newH * 4);
            for (let y = 0; y < newH; y++) {
                for (let x = 0; x < newW; x++) {
                    const idx = (y * newW + x) * 4;
                    newData[idx] = color[0];
                    newData[idx + 1] = color[1];
                    newData[idx + 2] = color[2];
                    newData[idx + 3] = color[3];
                }
            }
            for (let y = 0; y < this.height; y++) {
                for (let x = 0; x < this.width; x++) {
                    const srcIdx = (y * this.width + x) * 4;
                    const dstIdx = ((y + top) * newW + (x + left)) * 4;
                    newData.set(this.data.subarray(srcIdx, srcIdx + 4), dstIdx);
                }
            }
            return new Image(newW, newH, this.channels, newData);
        }
        tensor(options) {
            const mean = options.mean_values;
            const norm = options.norm_values;
            const width = this.width;
            const height = this.height;
            const numChannels = 3;
            const rgbaData = this.data;
            const tensor = new Float32Array(width * height * numChannels);
            for (let h = 0; h < height; h++) {
                for (let w = 0; w < width; w++) {
                    const pixelIndex = (h * width + w) * this.channels;
                    const tensorIndex = h * width + w;
                    for (let c = 0; c < numChannels; c++) {
                        const pixelValue = rgbaData[pixelIndex + c];
                        const normalizedValue = pixelValue * norm[c] - mean[c] * norm[c];
                        tensor[c * height * width + tensorIndex] = normalizedValue;
                    }
                }
            }
            return tensor;
        }
        threshold(options) {
            const threshold = options.threshold ?? 128;
            const width = this.width;
            const height = this.height;
            const binData = new Uint8Array(width * height);
            for (let i = 0; i < width * height; i++) {
                binData[i] = this.data[i * this.channels] > threshold ? 255 : 0;
            }
            return new Image(width, height, 1, binData);
        }
        dilate(options = {}) {
            const { norm = "LInf", k = 1 } = options;
            if (norm !== "LInf") {
                throw new Error("Only LInf norm is supported");
            }
            if (this.channels !== 1) {
                throw new Error("Dilate only supports single channel (grayscale) images");
            }
            const width = this.width;
            const height = this.height;
            const src = this.data;
            const INF = 999999;
            const dist = new Uint16Array(width * height);
            for (let i = 0; i < width * height; i++) {
                dist[i] = src[i] > 0 ? 0 : INF;
            }
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = y * width + x;
                    if (dist[idx] === 0)
                        continue;
                    let minDist = INF;
                    for (let dy = -1; dy <= 0; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            if (dx === 0 && dy === 0)
                                continue;
                            const nx = x + dx, ny = y + dy;
                            if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                                const nidx = ny * width + nx;
                                minDist = Math.min(minDist, dist[nidx] + 1);
                            }
                        }
                    }
                    dist[idx] = Math.min(dist[idx], minDist);
                }
            }
            for (let y = height - 1; y >= 0; y--) {
                for (let x = width - 1; x >= 0; x--) {
                    const idx = y * width + x;
                    if (dist[idx] === 0)
                        continue;
                    let minDist = INF;
                    for (let dy = 0; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            if (dx === 0 && dy === 0)
                                continue;
                            const nx = x + dx, ny = y + dy;
                            if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                                const nidx = ny * width + nx;
                                minDist = Math.min(minDist, dist[nidx] + 1);
                            }
                        }
                    }
                    dist[idx] = Math.min(dist[idx], minDist);
                }
            }
            const out = new Uint8Array(width * height);
            for (let i = 0; i < width * height; i++) {
                out[i] = dist[i] <= k ? 255 : 0;
            }
            return new Image(width, height, 1, out);
        }
        contours(options = {}) {
            const minArea = options.minArea ?? 1;
            const width = this.width;
            const height = this.height;
            const bin = new Uint8Array(width * height);
            for (let i = 0; i < width * height; i++) {
                bin[i] = this.data[i] > 0 ? 1 : 0;
            }
            const visited = new Uint8Array(width * height);
            const boxes = [];
            const at = (x, y) => y * width + x;
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    if (bin[at(x, y)] && !visited[at(x, y)]) {
                        let minX = x, minY = y, maxX = x, maxY = y, area = 0;
                        const queue = [[x, y]];
                        visited[at(x, y)] = 1;
                        while (queue.length) {
                            const [cx, cy] = queue.shift();
                            area++;
                            minX = Math.min(minX, cx);
                            minY = Math.min(minY, cy);
                            maxX = Math.max(maxX, cx);
                            maxY = Math.max(maxY, cy);
                            for (const [dx, dy] of [
                                [-1, 0],
                                [1, 0],
                                [0, -1],
                                [0, 1],
                                [-1, -1],
                                [1, -1],
                                [-1, 1],
                                [1, 1],
                            ]) {
                                const nx = cx + dx, ny = cy + dy;
                                if (nx >= 0 &&
                                    nx < width &&
                                    ny >= 0 &&
                                    ny < height &&
                                    bin[at(nx, ny)] &&
                                    !visited[at(nx, ny)]) {
                                    visited[at(nx, ny)] = 1;
                                    queue.push([nx, ny]);
                                }
                            }
                        }
                        if (area >= minArea) {
                            boxes.push({
                                x: minX,
                                y: minY,
                                width: maxX - minX + 1,
                                height: maxY - minY + 1,
                            });
                        }
                    }
                }
            }
            return boxes;
        }
        rect(options) {
            const { x, y, width, height, color = [], lineWidth = 1 } = options;
            if (!color.length) {
                color.push(...Array(this.channels).fill(255));
            }
            if (this.channels != color.length) {
                throw new Error(`Color length ${color.length} does not match image channels ${this.channels}`);
            }
            for (let dy = 0; dy < lineWidth; dy++) {
                for (let i = 0; i < width; i++) {
                    const yy = y + dy;
                    const xx = x + i;
                    if (yy >= 0 && yy < this.height && xx >= 0 && xx < this.width) {
                        const idx = (yy * this.width + xx) * this.channels;
                        this.data.set(color, idx);
                    }
                    const by = y + height - 1 - dy;
                    if (by >= 0 && by < this.height && xx >= 0 && xx < this.width) {
                        const idx = (by * this.width + xx) * this.channels;
                        this.data.set(color, idx);
                    }
                }
            }
            for (let dx = 0; dx < lineWidth; dx++) {
                for (let j = 0; j < height; j++) {
                    const xx = x + dx;
                    const yy = y + j;
                    if (xx >= 0 && xx < this.width && yy >= 0 && yy < this.height) {
                        const idx = (yy * this.width + xx) * this.channels;
                        this.data.set(color, idx);
                    }
                    const rx = x + width - 1 - dx;
                    if (rx >= 0 && rx < this.width && yy >= 0 && yy < this.height) {
                        const idx = (yy * this.width + rx) * this.channels;
                        this.data.set(color, idx);
                    }
                }
            }
        }
    }

    const DEFAULT_DETECTION_OPTIONS = {
        padding: 0,
        mean: [0.485 * 255, 0.456 * 255, 0.406 * 255],
        stdDeviation: [1 / 0.229 / 255, 1 / 0.224 / 255, 1 / 0.255 / 255],
        maxSideLength: 960,
        textPixelThreshold: 0.5,
        minimumAreaThreshold: 20,
        paddingBoxVertical: 0.4,
        paddingBoxHorizontal: 0.6,
    };
    const DEFAULT_RECOGNITION_OPTIONS = {
        mean: [127.5, 127.5, 127.5],
        stdDeviation: [1.0 / 127.5, 1.0 / 127.5, 1.0 / 127.5],
        imageHeight: 48,
        charactersDictionary: [],
    };
    const DEFAULT_PADDLE_OPTIONS = {
        detection: DEFAULT_DETECTION_OPTIONS,
        recognition: DEFAULT_RECOGNITION_OPTIONS,
    };

    class DetectionService {
        options;
        session;
        ortModule;
        constructor(ortModule, session, options = {}) {
            this.session = session;
            this.ortModule = ortModule;
            this.options = {
                ...DEFAULT_DETECTION_OPTIONS,
                ...options,
            };
        }
        async run(image) {
            const input = await this.preprocessDetection(image);
            const detection = await this.runInference(input.tensor, input.resizeParams);
            if (!detection) {
                return [];
            }
            const detectedBoxes = this.postprocessDetection(detection, input);
            return detectedBoxes;
        }
        async preprocessDetection(image) {
            const resizeParams = this.calculateResizeDimensions(image);
            const resizedImage = image.resize({
                width: resizeParams.dstWidth,
                height: resizeParams.dstHeight,
            });
            const tensor = resizedImage.tensor({
                mean_values: this.options.mean,
                norm_values: this.options.stdDeviation,
            });
            return {
                tensor,
                resizeParams,
            };
        }
        calculateResizeDimensions(image) {
            const MAX_SIDE_LEN = this.options.maxSideLength;
            const { width: srcWidth, height: srcHeight } = image;
            const ratio = srcWidth > srcHeight ? MAX_SIDE_LEN / srcWidth : MAX_SIDE_LEN / srcHeight;
            let dstWidth = Math.floor(srcWidth * ratio);
            let dstHeight = Math.floor(srcHeight * ratio);
            if (dstWidth % 32 !== 0)
                dstWidth = Math.max(Math.floor(dstWidth / 32) * 32, 32);
            if (dstHeight % 32 !== 0)
                dstHeight = Math.max(Math.floor(dstHeight / 32) * 32, 32);
            const scaleWidth = dstWidth / srcWidth;
            const scaleHeight = dstHeight / srcHeight;
            return {
                srcHeight,
                srcWidth,
                dstHeight,
                dstWidth,
                scaleWidth,
                scaleHeight,
            };
        }
        async runInference(tensor, resizeParams) {
            const inputTensor = new this.ortModule.Tensor("float32", tensor, [
                1,
                3,
                resizeParams.dstHeight,
                resizeParams.dstWidth,
            ]);
            const feeds = { x: inputTensor };
            const results = await this.session.run(feeds);
            const outputTensor = results[this.session.outputNames[0] || "fetch_name_0"];
            if (!outputTensor) {
                return null;
            }
            return outputTensor.data;
        }
        postprocessDetection(detection, input) {
            const { dstWidth, dstHeight } = input.resizeParams;
            const greyImage = new Image(dstWidth, dstHeight, 1, new Uint8Array(detection.map((v) => Math.round(v * 255))));
            const thresholdedImage = greyImage.threshold({
                threshold: 255 * this.options.textPixelThreshold,
            });
            const dilateImage = thresholdedImage.dilate({
                norm: "LInf",
                k: 1,
            });
            const boxes = dilateImage.contours({
                minArea: this.options.minimumAreaThreshold,
            });
            const finalBoxes = boxes.map((box) => {
                const paddedBox = this.applyPaddingToRect(box, dstWidth, dstHeight);
                const finalBox = this.convertToOriginalCoordinates(paddedBox, input.resizeParams);
                return finalBox;
            });
            return finalBoxes;
        }
        applyPaddingToRect(rect, maxWidth, maxHeight, paddingVertical = this.options.paddingBoxVertical || 0.6, paddingHorizontal = this.options.paddingBoxHorizontal || 0.8) {
            const verticalPadding = Math.round(rect.height * paddingVertical);
            const horizontalPadding = Math.round(rect.height * paddingHorizontal);
            let x = rect.x - horizontalPadding;
            let y = rect.y - verticalPadding;
            let width = rect.width + 2 * horizontalPadding;
            let height = rect.height + 2 * verticalPadding;
            x = Math.max(0, x);
            y = Math.max(0, y);
            const rightEdge = Math.min(maxWidth, rect.x + rect.width + horizontalPadding);
            const bottomEdge = Math.min(maxHeight, rect.y + rect.height + verticalPadding);
            width = rightEdge - x;
            height = bottomEdge - y;
            return { x, y, width, height };
        }
        convertToOriginalCoordinates(rect, resizeParams) {
            const scaledX = rect.x / resizeParams.scaleWidth;
            const scaledY = rect.y / resizeParams.scaleHeight;
            const scaledWidth = rect.width / resizeParams.scaleWidth;
            const scaledHeight = rect.height / resizeParams.scaleHeight;
            const x = Math.max(0, Math.round(scaledX));
            const y = Math.max(0, Math.round(scaledY));
            const width = Math.min(resizeParams.srcWidth - x, Math.round(scaledWidth));
            const height = Math.min(resizeParams.srcHeight - y, Math.round(scaledHeight));
            return { x, y, width, height };
        }
    }

    class RecognitionService {
        options;
        session;
        ortModule;
        constructor(ortModule, session, options = {}) {
            this.session = session;
            this.ortModule = ortModule;
            this.options = {
                ...DEFAULT_RECOGNITION_OPTIONS,
                ...options,
            };
        }
        async run(image, detection, options) {
            const validBoxes = detection.filter((box) => box.width > 0 && box.height > 0);
            const results = [];
            const charWhiteListSet = options?.charWhiteList?.length ? new Set(options.charWhiteList) : undefined;
            for (const [i, box] of validBoxes.entries()) {
                const result = await this.processBox({
                    image: image,
                    index: i,
                    box: box,
                    charWhiteSet: charWhiteListSet,
                });
                if (result) {
                    results.push(result);
                }
            }
            return this.sortResultsByReadingOrder(results);
        }
        async processBox(task) {
            const { image, box } = task;
            const crop = image.crop(box);
            const resizedCrop = crop.resize({
                height: this.options.imageHeight,
            });
            const tensor = resizedCrop.tensor({
                mean_values: this.options.mean,
                norm_values: this.options.stdDeviation,
            });
            const inputTensor = new this.ortModule.Tensor("float32", tensor, [1, 3, resizedCrop.height, resizedCrop.width]);
            const { data: outputData, dims: shape } = await this.runInference(inputTensor);
            const [, sequenceLength, numClasses] = shape;
            const { text: recognizedText, confidence } = this.ctcLabelDecode(outputData, sequenceLength, numClasses, task.charWhiteSet);
            return { text: recognizedText, box, confidence };
        }
        sortResultsByReadingOrder(results) {
            return [...results].sort((a, b) => {
                const boxA = a.box;
                const boxB = b.box;
                if (Math.abs(boxA.y - boxB.y) < (boxA.height + boxB.height) / 4) {
                    return boxA.x - boxB.x;
                }
                return boxA.y - boxB.y;
            });
        }
        async runInference(inputTensor) {
            const feeds = { x: inputTensor };
            const results = await this.session.run(feeds);
            const outputNodeName = Object.keys(results)[0];
            const outputTensor = results[outputNodeName];
            if (!outputTensor) {
                throw new Error(`Recognition output tensor '${outputNodeName}' not found. Available keys: ${Object.keys(results)}`);
            }
            return outputTensor;
        }
        ctcLabelDecode(logits, sequenceLength, numClasses, charWhiteSet) {
            const dict = this.options.charactersDictionary;
            let text = "";
            const scores = [];
            for (let t = 0; t < sequenceLength; t++) {
                let maxScore = 0;
                let maxScoreIndex = 0;
                for (let [index, score] of logits.slice(t * numClasses, (t + 1) * numClasses).entries()) {
                    if (score > maxScore) {
                        if (!charWhiteSet || charWhiteSet.has(dict[index]) || index === 0) {
                            maxScore = score;
                            maxScoreIndex = index;
                        }
                    }
                }
                if (maxScoreIndex === 0)
                    continue;
                const char = dict[maxScoreIndex] || "";
                text += char;
                scores.push(maxScore);
            }
            return {
                text,
                confidence: scores.reduce((sum, score) => sum + score, 0) / scores.length,
            };
        }
    }

    class PaddleOcrService {
        options;
        detectionSession = null;
        detectionService = null;
        recognitionSession = null;
        recognitionService = null;
        constructor(options) {
            if (!options?.ort) {
                throw new Error("PaddleOcrService requires the 'ort' option to be set with onnxruntime-node or onnxruntime-wen.");
            }
            this.options = {
                ...DEFAULT_PADDLE_OPTIONS,
                ...(options || {}),
            };
        }
        async initialize() {
            const ort = this.options.ort;
            if (!this.options.detection?.modelBuffer) {
                throw new Error("Detection model buffer is required. Please provide a valid ONNX model.");
            }
            this.detectionSession = await ort.InferenceSession.create(this.options.detection?.modelBuffer);
            this.detectionService = new DetectionService(this.options.ort, this.detectionSession, this.options.detection);
            if (!this.options.recognition?.modelBuffer) {
                throw new Error("Recognition model buffer is required. Please provide a valid ONNX model.");
            }
            this.recognitionSession = await ort.InferenceSession.create(this.options.recognition?.modelBuffer);
            this.recognitionService = new RecognitionService(this.options.ort, this.recognitionSession, this.options.recognition);
            if (!this.options.recognition?.charactersDictionary) {
                throw new Error(`options.recognition.characterDictionary is empty or not found.`);
            }
        }
        isInitialized() {
            return this.detectionSession !== null && this.recognitionSession !== null;
        }
        static async createInstance(options) {
            const instance = new PaddleOcrService(options);
            await instance.initialize();
            return instance;
        }
        async recognize(input, options) {
            if (!this.detectionService || !this.recognitionService) {
                throw new Error("PaddleOcrService is not initialized. Please call initialize() first.");
            }
            const channels = input.data.length / (input.width * input.height);
            if (!Number.isInteger(channels) || channels < 1 || channels > 4) {
                throw new Error(`Invalid input data: ${input.data} for image size ${input.width}x${input.height}. Expected 1, 3, or 4 channels.`);
            }
            let image = new Image(input.width, input.height, channels, input.data);
            const padding = this.options.detection?.padding ?? DEFAULT_DETECTION_OPTIONS.padding;
            if (padding) {
                image = image.padding({
                    padding,
                    color: [255, 255, 255, 255],
                });
            }
            const detection = await this.detectionService.run(image);
            const recognition = await this.recognitionService.run(image, detection, options);
            return recognition;
        }
        processRecognition(recognition) {
            const result = {
                text: "",
                lines: [],
                confidence: 0,
            };
            if (!recognition.length) {
                return result;
            }
            const totalConfidence = recognition.reduce((sum, r) => sum + r.confidence, 0);
            result.confidence = totalConfidence / recognition.length;
            let currentLine = [recognition[0]];
            let fullText = recognition[0].text;
            let avgHeight = recognition[0].box.height;
            for (let i = 1; i < recognition.length; i++) {
                const current = recognition[i];
                const previous = recognition[i - 1];
                const verticalGap = Math.abs(current.box.y - previous.box.y);
                const threshold = avgHeight * 0.5;
                if (verticalGap <= threshold) {
                    currentLine.push(current);
                    fullText += ` ${current.text}`;
                    avgHeight = currentLine.reduce((sum, r) => sum + r.box.height, 0) / currentLine.length;
                }
                else {
                    result.lines.push([...currentLine]);
                    fullText += `\n${current.text}`;
                    currentLine = [current];
                    avgHeight = current.box.height;
                }
            }
            if (currentLine.length > 0) {
                result.lines.push([...currentLine]);
            }
            result.text = fullText;
            return result;
        }
        async destroy() {
            await this.detectionSession?.release();
            await this.recognitionSession?.release();
        }
    }

    exports.DEFAULT_DETECTION_OPTIONS = DEFAULT_DETECTION_OPTIONS;
    exports.DEFAULT_PADDLE_OPTIONS = DEFAULT_PADDLE_OPTIONS;
    exports.DEFAULT_RECOGNITION_OPTIONS = DEFAULT_RECOGNITION_OPTIONS;
    exports.DetectionService = DetectionService;
    exports.PaddleOcrService = PaddleOcrService;
    exports.RecognitionService = RecognitionService;

}));
//# sourceMappingURL=index.js.map
